name: Hourly Counter (GMT-3) via Tailscale

on:
  schedule:
    - cron: "0 * * * *"     # a cada hora (UTC)
    - cron: "5 * * * *"     # redundância: dispara no minuto 5
  workflow_dispatch: {}

jobs:
  run:
    concurrency:
      group: peoplecounter-hourly
      cancel-in-progress: false   # evita paralelismo; enfileira redundante
    runs-on: ubuntu-latest
    timeout-minutes: 70
    permissions:
      contents: write

    # ---- Variáveis disponíveis para TODOS os passos (inclui o if) ----
    env:
      REPORT_MODE: 'gsheets_wide'                # grava no Google Sheets (aba larga)
      RUN_TZ: 'America/Sao_Paulo'
      HEADLESS_MAX_SEC: '3600'
      HEADLESS: '1'
      GSHEETS_CREDENTIALS_JSON: ${{ secrets.GSHEETS_CREDENTIALS_JSON }}
      GSHEETS_SPREADSHEET_ID: ${{ secrets.GSHEETS_SPREADSHEET_ID }}
      GSHEETS_WORKSHEET: ${{ secrets.GSHEETS_WORKSHEET }}

      # Câmera / resolver
      CAM_LAST_IP: ${{ secrets.CAM_LAST_IP }}
      CAM_CIDR:    ${{ secrets.CAM_CIDR }}
      CAM_USER:    ${{ secrets.CAM_USER }}
      CAM_PASS:    ${{ secrets.CAM_PASS }}
      CAM_PATH:    ${{ secrets.CAM_PATH }}
      CAM_PORT:    ${{ secrets.CAM_PORT }}

      # Reporter (Excel Online)
      EXCEL_TENANT_ID:     ${{ secrets.EXCEL_TENANT_ID }}
      EXCEL_CLIENT_ID:     ${{ secrets.EXCEL_CLIENT_ID }}
      EXCEL_CLIENT_SECRET: ${{ secrets.EXCEL_CLIENT_SECRET }}
      EXCEL_DRIVE_ID:      ${{ secrets.EXCEL_DRIVE_ID }}
      EXCEL_ITEM_ID:       ${{ secrets.EXCEL_ITEM_ID }}
      EXCEL_WORKSHEET:     ${{ secrets.EXCEL_WORKSHEET }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Tailscale up
        uses: tailscale/github-action@v2
        with:
          authkey: ${{ secrets.TS_AUTHKEY }}
          args: --accept-routes=true

      - name: Diagnose Tailscale and RTSP reachability
        if: ${{ github.event_name == 'workflow_dispatch' }}
        continue-on-error: true
        run: |
          set -euxo pipefail
          echo "=== tailscale status ==="
          tailscale status || true
          echo "=== ip route (IPv4) ==="
          ip -4 route || true
          echo "Testing TCP to ${CAM_LAST_IP}:${CAM_PORT}"
          python - << 'PY'
          import os, socket, sys
          ip = os.environ.get('CAM_LAST_IP')
          port = int(os.environ.get('CAM_PORT','554'))
          s = socket.socket()
          s.settimeout(5)
          try:
              s.connect((ip, port))
              print(f"OK: TCP connect to {ip}:{port}")
              sys.exit(0)
          except Exception as e:
              print(f"FAIL: TCP connect to {ip}:{port} -> {e}")
              sys.exit(1)
          finally:
              try:
                  s.close()
              except Exception:
                  pass
          PY

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          # Instala PyTorch CPU pelo índice oficial (evita falhas no PyPI padrão)
          pip install --index-url https://download.pytorch.org/whl/cpu \
            torch==2.2.2+cpu torchvision==0.17.2+cpu torchaudio==2.2.2+cpu
          # Demais dependências do projeto
          pip install -r requirements.txt

      - name: Compute wait and run window (tolerant start)
        id: prep
        run: |
          # pre-wait tolerante: sem 'set -e' para não falhar em tentativas
          PROBE_INTERVAL=60
          MAX_WAIT_SEC=1800
          MIN_RUN_SEC=1800
          SAFETY_MARGIN=30

          echo "Waiting (up to ${MAX_WAIT_SEC}s) for camera reachability ${CAM_LAST_IP}:${CAM_PORT}..."
          start_ts=$(date -u +%s)
          deadline=$((start_ts + MAX_WAIT_SEC))
          reachable=0
          next_resolve_ts=$start_ts   # tenta resolver imediatamente
          while [ $(date -u +%s) -lt $deadline ]; do
            now_loop=$(date -u +%s)

            # Tenta resolver IP real via camera_resolver no início e a cada 5 minutos
            if [ $now_loop -ge $next_resolve_ts ]; then
              echo "Attempting resolve_rtsp (CIDR scan) ..."
              if python -c "import os,sys; from camera_resolver import resolve_rtsp; \
url=resolve_rtsp(last_ip=os.getenv('CAM_LAST_IP'), cidr=os.getenv('CAM_CIDR'), user=os.getenv('CAM_USER'), password=os.getenv('CAM_PASS'), path=os.getenv('CAM_PATH'), port=int(os.getenv('CAM_PORT','554')), use_cache=False); \
print('URL' if url else ''); sys.exit(0 if url else 1)"; then
                echo "OK: resolver found URL"
                reachable=1; break
              fi
              next_resolve_ts=$((now_loop + 300))  # re-tenta em 5 min
            fi

            # Probe TCP no último IP conhecido
            if timeout 5 bash -c "</dev/tcp/${CAM_LAST_IP}/${CAM_PORT}" 2>/dev/null; then
              echo "OK: TCP reachability confirmed"
              reachable=1; break
            else
              echo "WAIT: not reachable yet"
            fi
            sleep ${PROBE_INTERVAL}
          done

          now=$(date -u +%s)
          next_hour=$(( ( (now/3600) + 1 ) * 3600 ))
          remain=$(( next_hour - now ))
          run_sec=$(( remain - SAFETY_MARGIN ))

          if [ $reachable -eq 0 ]; then
            echo "Camera not reachable within wait window; proceeding anyway with remaining time."
          fi

          if [ $run_sec -lt $MIN_RUN_SEC ]; then
            echo "Remaining time ${run_sec}s is below MIN_RUN_SEC=${MIN_RUN_SEC}s. Skipping this hour."
            echo "skip=true" >> "$GITHUB_OUTPUT"
            echo "run_sec=0" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ $run_sec -gt 3600 ]; then run_sec=3600; fi
          echo "Will run counter for ${run_sec}s (until top of next hour)."
          echo "skip=false" >> "$GITHUB_OUTPUT"
          echo "run_sec=${run_sec}" >> "$GITHUB_OUTPUT"

      - name: Run counter headless (~1h)
        if: ${{ steps.prep.outputs.skip != 'true' }}
        env:
          HEADLESS_MAX_SEC: ${{ steps.prep.outputs.run_sec }}
        run: |
          python run_counter_headless.py --last-ip "${CAM_LAST_IP}" --cidr "${CAM_CIDR}" --user "${CAM_USER}" --password "${CAM_PASS}" --path "${CAM_PATH}" --port "${CAM_PORT}"

      # Só roda se REPORT_MODE == 'csv'
      - name: Commit CSV (optional)
        if: ${{ env.REPORT_MODE == 'csv' }}
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@users.noreply.github.com"
          git add movimento_entradas.csv || true
          git commit -m "update csv" || true
          git push || true
