name: Hourly Counter (GMT-3) via Tailscale

on:
  schedule:
    - cron: "0 12-23 * * *"  # 12h-23h UTC = 9h-20h GMT-3
  workflow_dispatch:

jobs:
  run:
    concurrency:
      group: peoplecounter-hourly
      cancel-in-progress: true
    runs-on: ubuntu-latest
    timeout-minutes: 58
    permissions:
      contents: write

    env:
      REPORT_MODE: gsheets_wide
      RUN_TZ: America/Sao_Paulo
      HEADLESS: "1"
      SAVE_INTERVAL_SEC: "600"
      GSHEETS_CREDENTIALS_JSON: ${{ secrets.GSHEETS_CREDENTIALS_JSON }}
      GSHEETS_SPREADSHEET_ID: ${{ secrets.GSHEETS_SPREADSHEET_ID }}
      GSHEETS_WORKSHEET: ${{ secrets.GSHEETS_WORKSHEET }}
      CAM_LAST_IP: ${{ secrets.CAM_LAST_IP }}
      CAM_CIDR: ${{ secrets.CAM_CIDR }}
      CAM_USER: ${{ secrets.CAM_USER }}
      CAM_PASS: ${{ secrets.CAM_PASS }}
      CAM_PATH: ${{ secrets.CAM_PATH }}
      CAM_PORT: ${{ secrets.CAM_PORT }}
      EXCEL_TENANT_ID: ${{ secrets.EXCEL_TENANT_ID }}
      EXCEL_CLIENT_ID: ${{ secrets.EXCEL_CLIENT_ID }}
      EXCEL_CLIENT_SECRET: ${{ secrets.EXCEL_CLIENT_SECRET }}
      EXCEL_DRIVE_ID: ${{ secrets.EXCEL_DRIVE_ID }}
      EXCEL_ITEM_ID: ${{ secrets.EXCEL_ITEM_ID }}
      EXCEL_WORKSHEET: ${{ secrets.EXCEL_WORKSHEET }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Tailscale up
        uses: tailscale/github-action@v2
        with:
          authkey: ${{ secrets.TS_AUTHKEY }}
          args: --accept-routes=true

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: pip
          cache-dependency-path: requirements.txt

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install --index-url https://download.pytorch.org/whl/cpu \
            torch==2.2.2+cpu torchvision==0.17.2+cpu torchaudio==2.2.2+cpu
          pip install -r requirements.txt

      - name: Quick camera connectivity check
        id: cam_check
        continue-on-error: true
        timeout-minutes: 3
        shell: python
        run: |
          import os, socket, time
          
          def tcp_ok(ip: str, port: int, timeout: int = 5) -> bool:
            try:
              with socket.create_connection((ip, port), timeout=timeout):
                return True
            except Exception:
              return False
          
          last_ip = os.getenv('CAM_LAST_IP')
          port = int(os.getenv('CAM_PORT', '554'))
          
          for i in range(3):
            if tcp_ok(last_ip, port, timeout=5):
              print(f"âœ“ Camera reachable at {last_ip}:{port}")
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                f.write("reachable=true\n")
              exit(0)
            if i < 2:
              time.sleep(60)
          
          print(f"âœ— Camera NOT reachable at {last_ip}:{port}")
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
            f.write("reachable=false\n")

      - name: Calculate execution window
        id: timing
        shell: python
        run: |
          import os
          from datetime import datetime, timezone, timedelta
          
          cam_ok = '${{ steps.cam_check.outputs.reachable }}' == 'true'
          
          if not cam_ok:
            print("âš  Camera not reachable - SKIPPING this cycle")
            with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write("skip=true\n")
          else:
            # HorÃ¡rio atual em GMT-3
            now_utc = datetime.now(timezone.utc)
            now_gmt3 = now_utc - timedelta(hours=3)
            
            # Calcula deadline: minuto :55 da hora atual
            deadline = now_gmt3.replace(minute=55, second=0, microsecond=0)
            
            # Se jÃ¡ passou de :55, vai para :55 da prÃ³xima hora
            if now_gmt3.minute >= 55:
              deadline = deadline + timedelta(hours=1)
            
            # Tempo disponÃ­vel em segundos
            available_seconds = int((deadline - now_gmt3).total_seconds())
            
            # Reserva 2 minutos (120s) para salvamento final
            max_runtime = max(120, available_seconds - 120)
            
            print("=" * 60)
            print("â° CÃLCULO DE TEMPO DE EXECUÃ‡ÃƒO")
            print("=" * 60)
            print(f"HorÃ¡rio atual (GMT-3): {now_gmt3.strftime('%Y-%m-%d %H:%M:%S')}")
            print(f"Deadline (terminar em): {deadline.strftime('%H:%M:%S')}")
            print(f"Tempo disponÃ­vel: {available_seconds}s (~{available_seconds//60}min)")
            print(f"Tempo de execuÃ§Ã£o: {max_runtime}s (~{max_runtime//60}min {max_runtime%60}s)")
            print(f"Margem para salvamento: 120s (2min)")
            print("=" * 60)
            print("âœ“ Camera OK - starting counter")
            
            with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write("skip=false\n")
              f.write(f"max_runtime={max_runtime}\n")

      - name: Run counter headless
        if: steps.timing.outputs.skip != 'true'
        timeout-minutes: 57
        env:
          PYTHONUNBUFFERED: "1"
          HEADLESS_MAX_SEC: ${{ steps.timing.outputs.max_runtime }}
          RTSP_URL: "rtsp://${{ secrets.CAM_USER }}:${{ secrets.CAM_PASS }}@${{ secrets.CAM_LAST_IP }}:${{ secrets.CAM_PORT }}/${{ secrets.CAM_PATH }}"
        run: |
          echo "=" | tr -d '\n' | head -c 70 && echo
          echo "ðŸš€ INICIANDO CONTADOR HEADLESS"
          echo "=" | tr -d '\n' | head -c 70 && echo
          echo "â± Tempo mÃ¡ximo de execuÃ§Ã£o: ${HEADLESS_MAX_SEC}s (~$((HEADLESS_MAX_SEC/60))min)"
          echo "ðŸ’¾ Salvamento periÃ³dico: a cada ${SAVE_INTERVAL_SEC}s (~$((SAVE_INTERVAL_SEC/60))min)"
          echo "ðŸŽ¯ Objetivo: terminar sempre no minuto :55"
          echo "=" | tr -d '\n' | head -c 70 && echo
          python run_counter_headless.py 2>&1 | tee counter_output.log
          echo ""
          echo "=" | tr -d '\n' | head -c 70 && echo
          echo "âœ“ CONTADOR FINALIZADO"
          echo "=" | tr -d '\n' | head -c 70 && echo
      
      - name: Upload logs on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: counter-logs-${{ github.run_number }}
          path: |
            counter_output.log
            *.log
          retention-days: 7

      - name: Commit CSV
        if: env.REPORT_MODE == 'csv'
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@users.noreply.github.com"
          git add movimento_entradas.csv || true
          git commit -m "update csv" || true
          git push || true