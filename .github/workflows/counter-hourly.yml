name: Hourly Counter (GMT-3) via Tailscale

on:
  schedule:
    - cron: "0 * * * *"     # a cada hora (UTC)
    - cron: "5 * * * *"     # redundância: dispara no minuto 5
  workflow_dispatch: {}

jobs:
  run:
    concurrency:
      group: peoplecounter-hourly
      cancel-in-progress: false   # evita paralelismo; enfileira redundante
    runs-on: ubuntu-latest
    timeout-minutes: 70
    permissions:
      contents: write

    # ---- Variáveis disponíveis para TODOS os passos (inclui o if) ----
    env:
      REPORT_MODE: 'gsheets_wide'                # grava no Google Sheets (aba larga)
      RUN_TZ: 'America/Sao_Paulo'
      HEADLESS_MAX_SEC: '3600'
      HEADLESS: '1'
      GSHEETS_CREDENTIALS_JSON: ${{ secrets.GSHEETS_CREDENTIALS_JSON }}
      GSHEETS_SPREADSHEET_ID: ${{ secrets.GSHEETS_SPREADSHEET_ID }}
      GSHEETS_WORKSHEET: ${{ secrets.GSHEETS_WORKSHEET }}

      # Câmera / resolver
      CAM_LAST_IP: ${{ secrets.CAM_LAST_IP }}
      CAM_CIDR:    ${{ secrets.CAM_CIDR }}
      CAM_USER:    ${{ secrets.CAM_USER }}
      CAM_PASS:    ${{ secrets.CAM_PASS }}
      CAM_PATH:    ${{ secrets.CAM_PATH }}
      CAM_PORT:    ${{ secrets.CAM_PORT }}

      # Reporter (Excel Online)
      EXCEL_TENANT_ID:     ${{ secrets.EXCEL_TENANT_ID }}
      EXCEL_CLIENT_ID:     ${{ secrets.EXCEL_CLIENT_ID }}
      EXCEL_CLIENT_SECRET: ${{ secrets.EXCEL_CLIENT_SECRET }}
      EXCEL_DRIVE_ID:      ${{ secrets.EXCEL_DRIVE_ID }}
      EXCEL_ITEM_ID:       ${{ secrets.EXCEL_ITEM_ID }}
      EXCEL_WORKSHEET:     ${{ secrets.EXCEL_WORKSHEET }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Tailscale up
        uses: tailscale/github-action@v2
        with:
          authkey: ${{ secrets.TS_AUTHKEY }}
          args: --accept-routes=true

      - name: Diagnose Tailscale and RTSP reachability
        if: ${{ github.event_name == 'workflow_dispatch' }}
        continue-on-error: true
        run: |
          set -euxo pipefail
          echo "=== tailscale status ==="
          tailscale status || true
          echo "=== ip route (IPv4) ==="
          ip -4 route || true
          echo "Testing TCP to ${CAM_LAST_IP}:${CAM_PORT}"
          python - << 'PY'
          import os, socket, sys
          ip = os.environ.get('CAM_LAST_IP')
          port = int(os.environ.get('CAM_PORT','554'))
          s = socket.socket()
          s.settimeout(5)
          try:
              s.connect((ip, port))
              print(f"OK: TCP connect to {ip}:{port}")
              sys.exit(0)
          except Exception as e:
              print(f"FAIL: TCP connect to {ip}:{port} -> {e}")
              sys.exit(1)
          finally:
              try:
                  s.close()
              except Exception:
                  pass
          PY

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: |
            requirements.txt

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          # Instala PyTorch CPU pelo índice oficial (evita falhas no PyPI padrão)
          pip install --index-url https://download.pytorch.org/whl/cpu \
            torch==2.2.2+cpu torchvision==0.17.2+cpu torchaudio==2.2.2+cpu
          # Demais dependências do projeto
          pip install -r requirements.txt

      - name: Try initial resolve (optional)
        id: pre_resolve
        shell: python
        run: |
          import os
          try:
              from camera_resolver import resolve_rtsp
              url = resolve_rtsp(
                  last_ip=os.getenv('CAM_LAST_IP'),
                  cidr=os.getenv('CAM_CIDR'),
                  user=os.getenv('CAM_USER'),
                  password=os.getenv('CAM_PASS'),
                  path=os.getenv('CAM_PATH'),
                  port=int(os.getenv('CAM_PORT','554')),
                  use_cache=False,
              )
              ok = '1' if url else '0'
          except Exception:
              ok = '0'
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"ok={ok}\n")

      - name: Compute wait and run window (tolerant start)
        id: prep
        shell: python
        env:
          PROBE_INTERVAL: '60'
          MAX_WAIT_SEC: '1800'
          MIN_RUN_SEC: '1800'
          SAFETY_MARGIN: '30'
        run: |
          import os, time, socket, datetime as dt

          def tcp_ok(ip: str, port: int, timeout: int = 5) -> bool:
            try:
              with socket.create_connection((ip, port), timeout=timeout):
                return True
            except Exception:
              return False

          start = time.time()
          max_wait = int(os.getenv('MAX_WAIT_SEC', '1800'))
          probe = int(os.getenv('PROBE_INTERVAL', '60'))
          min_run = int(os.getenv('MIN_RUN_SEC', '1800'))
          overlap = 5  # segundos para terminar APÓS o topo da hora

          last_ip = os.getenv('CAM_LAST_IP')
          port = int(os.getenv('CAM_PORT', '554'))

          def try_resolve() -> bool:
            try:
              from camera_resolver import resolve_rtsp
              url = resolve_rtsp(
                last_ip=os.getenv('CAM_LAST_IP'),
                cidr=os.getenv('CAM_CIDR'),
                user=os.getenv('CAM_USER'),
                password=os.getenv('CAM_PASS'),
                path=os.getenv('CAM_PATH'),
                port=port,
                use_cache=False,
              )
              return bool(url)
            except Exception:
              return False

          # Primeiro tentamos o último IP. Só depois de 5 min começamos a resolver.
          next_resolve = start + 300
          reachable = False
          while time.time() - start < max_wait:
            now = time.time()
            # 1) Probe TCP no último IP conhecido, a cada minuto
            if tcp_ok(last_ip, port, timeout=5):
              reachable = True
              break
            # 2) Resolver a cada 5 minutos (após 5 min iniciais)
            if now >= next_resolve:
              if try_resolve():
                reachable = True
                break
              next_resolve = now + 300
            time.sleep(probe)

          # Calcula tempo restante até o topo da próxima hora (UTC)
          now_utc = dt.datetime.utcnow()
          next_hour = (now_utc.replace(minute=0, second=0, microsecond=0)
                       + dt.timedelta(hours=1))
          remain = int((next_hour - now_utc).total_seconds())
          run_sec = max(0, remain + overlap)
          # limita a no máximo ~3610s
          if run_sec > 3610:
            run_sec = 3610

          skip = run_sec < min_run
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
            f.write(f"skip={'true' if skip else 'false'}\n")
            f.write(f"run_sec={0 if skip else run_sec}\n")

      - name: Run counter headless (~1h)
        if: ${{ steps.prep.outputs.skip != 'true' }}
        env:
          HEADLESS_MAX_SEC: ${{ steps.prep.outputs.run_sec }}
        run: |
          python run_counter_headless.py --last-ip "${CAM_LAST_IP}" --cidr "${CAM_CIDR}" --user "${CAM_USER}" --password "${CAM_PASS}" --path "${CAM_PATH}" --port "${CAM_PORT}"

      # Só roda se REPORT_MODE == 'csv'
      - name: Commit CSV (optional)
        if: ${{ env.REPORT_MODE == 'csv' }}
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@users.noreply.github.com"
          git add movimento_entradas.csv || true
          git commit -m "update csv" || true
          git push || true
